'use strict';
var mongoose = require('mongoose'),
	crypto = require('crypto'),
	Schema = mongoose.Schema;

var UserSchema = new Schema({
	firstName: String,
	lastName: String,
	email: {
		type: String,
		match: [/.+\@.+\..+/, 'Please fill a valid email address']
	},
	username: {
		type: String,
		trim: true,
		unique: true,
		required: 'Username is required'
	},
	password: {
		type: String,
		validate: [
			function(password) {
				return password && password.length > 6;
			}, 'Password should be longer'
		]
	},
	// property used to hash password
	salt: {
		type: String
	},
	// property which will indicate the strategy used to register
	// the user (local or oAuth)
	provider: {
		type: String,
		required: 'Provider is required'
	},
	// property which will indicate the user identifier for the 
	// strategy
	providerId: String,
	// used to store the user object retrieved from OAuth
	// providers
	providerData: {},
	created: {
		type: Date,
		default: Date.now
	}
});

// Dynamically calculate doc properties which are not
// really presented in the documents, called 'virtual 
// attributes' (Chpt 5: Adding VirtAttr)
/*UserSchema.virtual('fullName').get(function() {
	return this.firstName +" "+ this.lastName;
});*/

// Break an input's 'fullName' field into first and last name
// fields.  
UserSchema.virtual('fullName').get(function() {
	return this.firstName + ' ' + this.lastName;
}).set(function(fullName) {
	var splitName = fullName.split(' ');
	this.firstName = splitName[0] || '';
	this.lastName = splitName[1] || '';
});

// pre-save middleware to handle the hasing of users' pw in
// two steps: 1) it creates an autogenerated  pseudo-random
// hashing salt, and 2) replaces the current user pw w/ a 
// hashed pw using the hashPassword instance method
UserSchema.pre('save', function(next) {
	if (this.password) {
		this.salt = new Buffer(crypto.randomBytes(16).toString('base64'), 'base64');
		this.password = this.hashPassword(this.password);
	}

	next();
});

// TWO INSTANCE METHODS

// used to hash a password string using crypto module
UserSchema.methods.hashPassword = function(password) {
	return crypto.pbkdf2Sync(password, this.salt, 10000, 64).toString('base64');
};

// accepts a string argument, hashes it, and compares it
// to the current user's hashed password
UserSchema.methods.authenticate = function(password) {
	return this.password === this.hashPassword(password);
};

// STATIC METHOD

// used to find an available unique username for new users
UserSchema.statics.findUniqueUsername = function (username, suffix, callback) {
	var _this = this;
	var possibleUsername = username + (suffix || '');
	
	_this.findOne({
		username: possibleUsername
	}, function(err, user) {
		if (!err) {
			if (!user) {
				callback(possibleUsername);
			} else {
				return _this.findUniqueUsername(username, (suffix || 0) + 1, callback);
			}
		} else {
			callback(null);
		}
	});
};

// Configured your schema using GirlsSchema.set()
// Forces Mongoose to include getters when converting 
// the MongoDB doc to a JSON representation and will
// allow the output of documents using res.json() to
// include the getter's behavior, 
UserSchema.set('toJSON', { 
	getters: true, 
	virtuals: true
});

mongoose.model('User', UserSchema);